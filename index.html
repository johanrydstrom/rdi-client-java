<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Rdi-client-java by metamx</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Rdi-client-java</h1>
        <p>Hoppy has to make the lumber deal happen and solve the murder.</p>

        <p class="view"><a href="https://github.com/metamx/rdi-client-java">View the Project on GitHub <small>metamx/rdi-client-java</small></a></p>


        <ul>
          <li><a href="https://github.com/metamx/rdi-client-java/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/metamx/rdi-client-java/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/metamx/rdi-client-java">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h2>
<a id="overview" class="anchor" href="#overview" aria-hidden="true"><span class="octicon octicon-link"></span></a>Overview</h2>

<p>The RdiClient for Java is a client library for posting event streams to Metamarkets' real-time data ingestion (RDI) API, which receives and processes event data in real-time.  The client comes with functionality to handle connecting to the HTTPS endpoint, authentication, serialization &amp; batching events, HTTP transport, and error handling (w/ exponential-backoff retries).</p>

<h2>
<a id="usage" class="anchor" href="#usage" aria-hidden="true"><span class="octicon octicon-link"></span></a>Usage</h2>

<h3>
<a id="getting-started" class="anchor" href="#getting-started" aria-hidden="true"><span class="octicon octicon-link"></span></a>Getting Started</h3>

<p>To create the client, you'll need to pass a config and a serializer.  The following is an example of creating the client and using the basic API for passing event records:</p>

<div class="highlight highlight-java"><pre><span class="pl-s">final</span> <span class="pl-stj">String</span> feed <span class="pl-k">=</span> <span class="pl-s1"><span class="pl-pds">"</span>&lt;PROVIDED_BY_MMX&gt;<span class="pl-pds">"</span></span>;
<span class="pl-s">final</span> <span class="pl-stj">String</span> endpoint <span class="pl-k">=</span> <span class="pl-stj">String</span><span class="pl-k">.</span>format(<span class="pl-s1"><span class="pl-pds">"</span>https://rt-test.mmx.io/events/%s<span class="pl-pds">"</span></span>, feed);
<span class="pl-s">final</span> <span class="pl-stj">String</span> username <span class="pl-k">=</span> <span class="pl-s1"><span class="pl-pds">"</span>&lt;PROVIDED_BY_MMX&gt;<span class="pl-pds">"</span></span>;
<span class="pl-s">final</span> <span class="pl-stj">String</span> password <span class="pl-k">=</span> <span class="pl-s1"><span class="pl-pds">"</span>PROVIDED_BY_MMX&gt;<span class="pl-pds">"</span></span>;

<span class="pl-s">final</span> <span class="pl-stj">RdiClientConfig</span> config <span class="pl-k">=</span> <span class="pl-stj">RdiClientConfig</span><span class="pl-k">.</span>builder()
                                              .username(username)
                                              .password(password)
                                              .mmxBaseUrl(endpoint)
                                              .build();

<span class="pl-s">final</span> <span class="pl-st">RdiClient&lt;<span class="pl-stj">MmxAuctionSummary</span>&gt;</span> client <span class="pl-k">=</span> <span class="pl-stj">RdiClients</span><span class="pl-k">.</span>usingJacksonSerializer(config);

client<span class="pl-k">.</span>start();

<span class="pl-k">for</span> (message <span class="pl-k">:</span> messages) {
  client<span class="pl-k">.</span>send(message);
}

client<span class="pl-k">.</span>flush();
client<span class="pl-k">.</span>close();</pre></div>

<h3>
<a id="data-format--serialization" class="anchor" href="#data-format--serialization" aria-hidden="true"><span class="octicon octicon-link"></span></a>Data Format &amp; Serialization</h3>

<p>Metamarkets API currently accepts JSON event data with UTF-8 encoding.  We have a jackson-based serialization library available (<a href="https://github.com/metamx/rad-tech-datatypes">link here</a>) for generating the OpenRTB-based event records which may be used in conjunction with the RDI Client. </p>

<p>For more information on the required data types, please contact your Metamarkets representative.  </p>

<p>The client requires a "serializer" class to be passed for converting messages to byte arrays prior to posting.  There are two built in serializers available:</p>

<ul>
<li>JacksonSerializer: Uses a Jackson ObjectMapper to serialize events to byte arrays.  This library comes with default methods for creating a client for posting <a href="https://github.com/metamx/rad-tech-datatypes">Metamarkets' standard data types</a>.<br>
</li>
</ul>

<div class="highlight highlight-java"><pre><span class="pl-c">// For MmxAuctionSummary events:</span>
<span class="pl-s">final</span> <span class="pl-st">RdiClient&lt;<span class="pl-stj">MmxAuctionSummary</span>&gt;</span> client <span class="pl-k">=</span> <span class="pl-stj">RdiClients</span><span class="pl-k">.</span>usingJacksonSerializer(config);</pre></div>

<ul>
<li>PassthroughSerializer: Use for passing pre-serialized events as a byte array.  This option may be used in cases where serialization is handled upstream.</li>
</ul>

<div class="highlight highlight-java"><pre><span class="pl-s">final</span> <span class="pl-st">RdiClient&lt;byte[]&gt;</span> client <span class="pl-k">=</span> <span class="pl-stj">RdiClients</span><span class="pl-k">.</span>makeDefault(config, <span class="pl-k">new</span> <span class="pl-stj">PassthroughSerializer</span>());</pre></div>

<h3>
<a id="compression" class="anchor" href="#compression" aria-hidden="true"><span class="octicon octicon-link"></span></a>Compression</h3>

<p>The Metamarkets API currently only supports gzip compression.  You may enable compression by setting the "contentEncoding" configuration parameter to ".contentEncoding(RdiClientConfig.ContentEncoding.GZIP)".  Otherwise it will default to "NONE".  </p>

<p>Because events will be compressed by the library, you should not compress them prior to calling the client.</p>

<h3>
<a id="scaling" class="anchor" href="#scaling" aria-hidden="true"><span class="octicon octicon-link"></span></a>Scaling</h3>

<p>Each RdiClient instance maintains one connection to the server.  If you need multiple connections to improve throughput, you should use multiple instances of the client simultaneously.</p>

<p>Please note that RdiClient is not thread-safe, so if one instance is used for multiple threads, access must be synchronized.</p>

<h3>
<a id="posting-data--handling-responses" class="anchor" href="#posting-data--handling-responses" aria-hidden="true"><span class="octicon octicon-link"></span></a>Posting Data &amp; Handling Responses</h3>

<p>Data should be delivered in a smooth and continuous pattern.  When a new batch of data is posted, the Metamarkets API should respond with an HTTP 2xx response code within 50-100ms unless an error is encountered.  Typical causes for errors when posting event data to the API endpoint include connectivity/network issues, or bad HTTP responses from the server due to issues such as exceeding your rate limit (HTTP 420), incorrect credentials (HTTP 401), or server issues (HTTP 500s).  Attempting to deliver data in large batches (e.g. once every few minutes or hour) is likely to cuase the volume rate to exceed your quota and result in a failed upload.</p>

<p>The client uses an exponential backoff retry strategy for all types of POST failures.  The maximum number of retries is set in your RdiClientConfig, where the default is 20 (which could lead to retries lasting up to 15 minutes).  </p>

<p>In the event that the client is unable to POST your data despite exhausting all retries, an RdiException will be thrown and will kill the process if left unhandled.  If the RdiException is caused by an unsuccessful attempt to POST data to the Metamarkets endpoint, the exception will be an instance of an RdiPostFailedException, from which the response code can be obtained via the "getStatusCode" method.  You should parse the exceptions to build out your own custom error handling.</p>

<h3>
<a id="delivering-data-on-time" class="anchor" href="#delivering-data-on-time" aria-hidden="true"><span class="octicon octicon-link"></span></a>Delivering Data "On Time"</h3>

<p>Metamarkets RDI expects data be uploaded in real-time.  Although "late" data will still be accepted by the API, it may not be processed in real-time.  "Current data" is defined as data with events that have a timestamp no more than 10 minutes behind the time the data is posted to RDI.Data with a timestamp more than 10 minutes older than current time is saved and surfaced in your dashboard usually within 48 hours. </p>

<p>If your data uploads fall behind, do not attempt to backfill all of the data by uploading it at once. That will likely exceed your volume quota and result in a failed upload (HTTP 420 error code). Instead, increase the overall throughput rate at which data is posted to a level between the normal rate and the quota (but no more than twice the normal rate), until data timestamps are near current time. If an HTTP 420 error code is returned, reduce the rate.</p>

<h3>
<a id="where-to-implement-the-rdiclient" class="anchor" href="#where-to-implement-the-rdiclient" aria-hidden="true"><span class="octicon octicon-link"></span></a>Where to Implement the RdiClient</h3>

<p>We strongly recommend that customers run the client safely out of band of mission-critical systems (e.g. servers conducting auctions or bidding).  The client <em>will block</em> when you call "flush" (and periodically upon calling "send") until events are successfully posted.  It is best practice to use a message queue (e.g. Kafka or RabbitMQ) for buffering data prior to delivery to the Metamarkets API.  Log retention should be set to a window long enough to allow for retention of data in the event of issues posting data to RDI.  We typically recommend that customers keep the data for 5-7 days.</p>

<h3>
<a id="kafka-example" class="anchor" href="#kafka-example" aria-hidden="true"><span class="octicon octicon-link"></span></a>Kafka Example</h3>

<p>Although the RDI client does not require a particular upstream message queue, we have provided an example implementation for Kafka in the "kafka-example" module.  Commits are done manually in order to support a "guaranteed delivery" approach.  </p>

<p>*** Recommend that people download the jar from the java docs -&gt; one for core and one for the kafka example.</p>

<h3>
<a id="jars" class="anchor" href="#jars" aria-hidden="true"><span class="octicon octicon-link"></span></a>JARs</h3>

<p>RdiClient artifacts are hosted on the Metamarkets maven repository: <a href="https://metamx.artifactoryonline.com/metamx/pub-libs-releases-local/">https://metamx.artifactoryonline.com/metamx/pub-libs-releases-local/</a>.
If you set up your project to know about this repository, you can depend on one of the hosted versions.</p>

<p>The current stable version is:</p>

<div class="highlight highlight-xml"><pre>&lt;<span class="pl-ent">dependency</span>&gt;
  &lt;<span class="pl-ent">groupId</span>&gt;com.metamx&lt;/<span class="pl-ent">groupId</span>&gt;
  &lt;<span class="pl-ent">artifactId</span>&gt;update!!&lt;/<span class="pl-ent">artifactId</span>&gt;
  &lt;<span class="pl-ent">version</span>&gt;update!!&lt;/<span class="pl-ent">version</span>&gt;
&lt;/<span class="pl-ent">dependency</span>&gt;</pre></div>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/metamx">metamx</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>